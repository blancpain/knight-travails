/* eslint-disable no-console */
/* eslint-disable max-classes-per-file */
class Square {
  constructor(value) {
    this.value = value;
    this.connections = [];
  }

  connect(node) {
    this.connections.push(node);
    node.connections.push(this);
  }
}

class Board {
  constructor() {
    this.squares = this.buildBoard();
  }

  buildBoard() {
    // build all the squares(verticies) in the board
    const squares = [];
    for (let i = 0; i < 8; i += 1) {
      for (let j = 0; j < 8; j += 1) {
        const newSquare = new Square([i, j]);
        squares.push(newSquare);
      }
    }

    // iterate over all squares and for each square
    // iterate over all possible moves generated by the
    // helper function and add them as edges/connections
    squares.forEach((square) => {
      for (const [moveRow, moveCol] of this.determineLegalMoves(square)) {
        // lookup the square with matching coordinates from all squares
        squares.forEach((node) => {
          if (
            node.value.toString() === [moveRow, moveCol].toString() &&
            !square.connections.includes(node) &&
            node.value.toString() !== square.value.toString()
          ) {
            square.connect(node);
          }
        });
      }
    });
    return squares;
  }

  // generator helper function to loop over offsets and return
  // coordinates for a legal target square the knight can jump to
  *determineLegalMoves(square) {
    const MOVE_OFFSETS = [
      [-1, -2],
      [1, -2],
      [-2, -1],
      [2, -1],
      [-2, 1],
      [2, 1],
      [-1, 2],
      [1, 2],
    ];

    for (const [rowOffset, colOffset] of MOVE_OFFSETS) {
      let [moveRow, moveCol] = square.value;
      moveRow += rowOffset;
      moveCol += colOffset;
      if (moveRow >= 0 && moveRow < 8 && moveCol >= 0 && moveCol < 8) {
        yield [moveRow, moveCol];
      }
    }
  }

  knightTravails(start, destination) {
    if (start === destination) {
      console.log("You are on the same square!");
      return;
    }
    // create visited Set
    const visited = new Set();

    // initialise queue for BFS
    const queue = [start];

    // initialise predecessor obj and tail
    const predecessor = {};
    let tail = 0;

    // initialise path
    let path;

    while (tail < queue.length) {
      // with u we denote the previous node/square,
      // here we assign it to queue[0] and increment by 1
      let u = queue[tail++];

      if (!u.connections) continue;

      const connections = u.connections;

      for (let i = 0; i < connections.length; i++) {
        // with v we denote the next node/square
        const v = connections[i];
        if (visited.has(v)) continue;
        visited.add(v);

        if (v === destination) {
          path = [v];

          // if we found the destination we backtrack to root
          // to fidn the path
          while (u !== start) {
            path.push(u);
            u = predecessor[u];
          }
          path.push(u);
          path.reverse();
          return path;
        }
        predecessor[v] = u;
        queue.push(v);
      }
    }
  }
}

// knightTravails(start, destination) {
//   // create visited Set
//   const visited = new Set();
//   visited.add(start);
//
//   // initialise queue for BFS
//   const queue = [];
//   queue.push(start);
//
//   // initialise path array
//   const path = [];
//
//   while (queue.length > 0) {
//     const currentSquare = queue.shift();
//
//     // check if we have reached the square
//     if (currentSquare === destination) {
//       console.log(`You made it in ${path.length} moves! Here is your path:`);
//       for (const step of path) {
//         console.log(step.value);
//       }
//       return;
//     }
//
//     // else continue through graph
//     currentSquare.connections.forEach((connection) => {
//       if (!visited.has(connection)) {
//         visited.add(connection);
//         queue.push(connection);
//       }
//     });
//   }
// }

const board = new Board();

const startingSq = board.squares[27];
const destinationSq = board.squares[35];

// console.log(startingSq, destinationSq);

board.knightTravails(startingSq, destinationSq);
