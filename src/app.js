/* eslint-disable no-console */
/* eslint-disable max-classes-per-file */
class Square {
  constructor(value) {
    this.value = value;
    this.connections = [];
  }

  connect(node) {
    this.connections.push(node);
    node.connections.push(this);
  }
}

class Board {
  constructor() {
    this.squares = this.buildBoard();
  }

  buildBoard() {
    const squares = [];
    for (let i = 0; i < 8; i += 1) {
      for (let j = 0; j < 8; j += 1) {
        const newSquare = new Square([i, j]);
        squares.push(newSquare);
      }
    }

    // iterate over all squares
    // for each square iterate over all possible moves
    // generated by the helper function and add them as edges/connections
    squares.forEach((square) => {
      for (const [moveRow, moveCol] of this.determineLegalMoves(square)) {
        // lookup the square with matching coordinates from all squares
        squares.forEach((node) => {
          if (
            node.value.toString() === [moveRow, moveCol].toString() &&
            !square.connections.includes(node) &&
            node.value.toString() !== square.value.toString()
          ) {
            square.connect(node);
          }
        });
      }
    });
    return squares;
  }

  // generator helper function to loop over offsets and return
  // coordinates for a legal target square the knight can jump to
  *determineLegalMoves(square) {
    const MOVE_OFFSETS = [
      [-1, -2],
      [1, -2],
      [-2, -1],
      [2, -1],
      [-2, 1],
      [2, 1],
      [-1, 2],
      [1, 2],
    ];

    for (const [rowOffset, colOffset] of MOVE_OFFSETS) {
      let [moveRow, moveCol] = square.value;
      moveRow += rowOffset;
      moveCol += colOffset;
      if (moveRow >= 0 && moveRow < 8 && moveCol >= 0 && moveCol < 8) {
        yield [moveRow, moveCol];
      }
    }
  }

  knightTravails(start, destination) {
    // create visited Set
    const visited = new Set();
    visited.add(start);

    // initialise queue for BFS
    const queue = [];
    queue.push(start);

    while (queue.length > 0) {
      const currentSquare = queue[0];
      queue.shift();
      for (let i = 0; i < currentSquare.connections.length; i += 1) {
        const currentConnection = currentSquare.connections[i];
        if (currentConnection === destination) {
          visited.add(currentConnection);
          const msg = visited.size - 1 < 2 ? "move" : "moves";
          console.log(
            `You made it in ${visited.size - 1} ${msg}! Here is your path:`
          );
          for (const step of visited) {
            console.log(step.value);
          }
          return;
        }
      }
      for (let i = 0; i < currentSquare.connections.length; i += 1) {
        const currentConnection = currentSquare.connections[i];
        if (!visited.has(currentConnection)) {
          visited.add(currentConnection);
          queue.push(currentConnection);
        }
      }
    }
  }
}

// knightTravails(start, destination) {
//   // create visited Set
//   const visited = new Set();
//   visited.add(start);
//
//   // initialise queue for BFS
//   const queue = [];
//   queue.push(start);
//
//   // initialise path to store squares moved to
//   const path = [];
//
//   while (queue.length > 0) {
//     const currentSquare = queue[0];
//     console.log(queue[0]);
//     queue.shift();
//
//     path.push(currentSquare);
//     // check if we have reached the square
//     if (currentSquare === destination) {
//       console.log(`You made it in ${path.length} moves! Here is your path:`);
//       for (const step of path) {
//         console.log(step.value);
//       }
//       console.log(visited);
//       break;
//     }
//     // else continue thru graph
//     currentSquare.connections.forEach((connection) => {
//       if (!visited.has(connection)) {
//         visited.add(connection);
//         queue.push(connection);
//       }
//     });
//   }
// }

const board = new Board();

const startingSq = board.squares[63];
const destinationSq = board.squares[53];

console.log(startingSq, destinationSq);

board.knightTravails(startingSq, destinationSq);
