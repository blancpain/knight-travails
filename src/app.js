/* eslint-disable class-methods-use-this */
/* eslint-disable no-param-reassign */
/* eslint-disable no-console */
/* eslint-disable max-classes-per-file */
class Square {
  constructor(value) {
    this.value = value;
    this.connections = [];
  }

  connect(node) {
    this.connections.push(node);
    node.connections.push(this);
  }
}

class Board {
  constructor() {
    this.squares = this.buildBoard();
  }

  buildBoard() {
    // build all the squares(verticies) in the board
    const squares = [];
    for (let i = 0; i < 8; i += 1) {
      for (let j = 0; j < 8; j += 1) {
        const newSquare = new Square([i, j]);
        squares.push(newSquare);
      }
    }

    // iterate over all squares and for each square
    // iterate over all possible moves generated by the
    // helper function and add them as edges/connections
    squares.forEach((square) => {
      for (const [moveRow, moveCol] of this.determineLegalMoves(square)) {
        // lookup the square with matching coordinates from all squares
        squares.forEach((node) => {
          if (
            node.value.toString() === [moveRow, moveCol].toString() &&
            !square.connections.includes(node) &&
            node.value.toString() !== square.value.toString()
          ) {
            square.connect(node);
          }
        });
      }
    });
    return squares;
  }

  // generator helper function to loop over offsets and return
  // coordinates for a legal target square the knight can jump to
  *determineLegalMoves(square) {
    const MOVE_OFFSETS = [
      [-1, -2],
      [1, -2],
      [-2, -1],
      [2, -1],
      [-2, 1],
      [2, 1],
      [-1, 2],
      [1, 2],
    ];

    for (const [rowOffset, colOffset] of MOVE_OFFSETS) {
      let [moveRow, moveCol] = square.value;
      moveRow += rowOffset;
      moveCol += colOffset;
      if (moveRow >= 0 && moveRow < 8 && moveCol >= 0 && moveCol < 8) {
        yield [moveRow, moveCol];
      }
    }
  }

  knightTravails(start, destination) {
    // lookup start and end squares
    this.squares.forEach((square) => {
      if (square.value.toString() === [start].toString()) {
        start = square;
      }
      if (square.value.toString() === [destination].toString()) {
        destination = square;
      }
    });

    if (start === destination) {
      console.log("You are on the same square!");
      return;
    }

    // utilise Set for visited squares as only unique values allowed
    const visited = new Set();
    // we use queue to store not only the connections but also
    // the full path to that particular square
    const queue = [[start, []]];

    while (queue.length) {
      // we use the spread operator for path to make sure
      // we are creating a shallow copy of the path array and we
      // update it for each connection/square to ensure we are not
      // mutating the original array
      const [curSq, [...path]] = queue.shift();
      path.push(curSq);

      if (curSq === destination) {
        // once we have located the right square we already have path
        // stored and updated so we can use that
        const numOfMoves = path.length - 1;
        const msg = numOfMoves === 1 ? "move" : "moves";
        console.log(`You made it in ${numOfMoves} ${msg}! Here is your path:`);
        for (const step of path) {
          console.log(step.value);
        }
        return;
      }

      if (!visited.has(curSq)) {
        // add the next connection(square) and the full path to it
        // the path would be the same across all connections in this current
        // loop as the path IS in fact the same from a given square each of
        // these squares
        queue.push(...curSq.connections.map((v) => [v, path]));
      }

      visited.add(curSq);
    }
  }
}

const board = new Board();

// testing...
board.knightTravails([3, 3], [4, 3]);
console.log("------------------------------");
board.knightTravails([0, 0], [1, 2]);
console.log("------------------------------");
board.knightTravails([3, 1], [7, 7]);
